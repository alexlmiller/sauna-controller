esphome:
  name: sauna-controller
  friendly_name: Sauna Controller
  project:
    name: sauna.open_controller
    version: "1.0"

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP_TASK_WDT: "y"
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "30"

logger:
  level: INFO
  baud_rate: 0

ota:
  platform: esphome
  password: !secret ota_password

api:
  encryption:
    key: !secret api_key

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: ${friendly_name}_AP
    password: !secret wifi_fallback_pw

web_server:
  port: 80
  
captive_portal:

############### GLOBALS ###############
globals:
  - id: fault_latched # Is The Sauna in Fault
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_trip_reason # Last Trip Reason
    type: std::string
    restore_value: no
    initial_value: ""
  - id: session_start_ms # Sauna Start Time
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: session_active # Is Sauna in Use
    type: bool
    restore_value: no
    initial_value: "false"
  - id: door_open_since # Door Open Time
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: welded_detect_since # Welded Contactor Trip Time
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: coil_is_on # Track actual coil state for welded detection
    type: bool
    restore_value: no
    initial_value: "false"

number:
  - platform: template   # Door-open timeout before tripping (seconds)
    name: "Door Open Fault Seconds"
    id: door_open_fault_s
    min_value: 15
    max_value: 300
    step: 5
    optimistic: true
    restore_value: true
    initial_value: 45
  - platform: template  # Software high-temp trip (°F)
    name: "Software High Temp °F"
    id: soft_high_temp_f
    min_value: 190
    max_value: 230
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 210

################### INPUTS ###################

binary_sensor:

# ----- Door Sensor -----
  - platform: gpio
    id: door_sensor
    name: "Sauna Door"
    device_class: door
    pin:
      number: GPIO22  # Changed from GPIO21 - GPIO21 not responding
      mode:
        input: true
        pullup: true
      inverted: false    # NO reed switch: closed pulls LOW, open pulls HIGH
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_state:
      then:
        - logger.log:
            format: "Door sensor changed to: %s"
            args: ['x ? "OPEN" : "CLOSED"']

# ----- Contactor Status (Aux Relay) -----  
  - platform: gpio
    id: contactor_aux_closed
    name: "Contactor Aux Closed"
    pin:
      number: GPIO32
      mode:
        input: true
        pullup: true
    filters:
      - lambda: return !x;      # TRUE when aux closed (opto pulls low)
      - delayed_on: 50ms
      - delayed_off: 50ms

# ----- High Limit Trip -----  
  - platform: gpio
    id: high_limit_trip
    name: "High Limit Trip"
    pin:
      number: GPIO33
      mode:
        input: true
        pullup: true
    filters:
      - lambda: return x;      # FALSE when tripped (opto pulls high)
      - delayed_on: 100ms
      - delayed_off: 100ms

# # ----- Future Opto Monitoring -----  
#   - platform: gpio
#     id: future_monitoring
#     name: "Future Monitoring"
#     pin:
#       number: GPIO25
#       mode:
#         input: true
#         pullup: true
#     filters:
#       - lambda: return !x;      # TRUE when tripped (opto pulls low)
#       - delayed_on: 100ms
#       - delayed_off: 100ms

################### TEMP SENSORS ###################

# ----- Inputs -----
one_wire:
# Bus 1 Input for Bench Temp Sensor
  - platform: gpio
    pin: GPIO26
    id: bus1
# Bus 2 Input for Ceiling Temp Sensor 
  - platform: gpio
    pin: GPIO27
    id: bus2

# ----- Sensors -----
sensor:
# Bench Temp
  - platform: dallas_temp
    one_wire_id: bus1
    name: "Bench Temp"
    id: bench_temp_c
    resolution: 10
    update_interval: 5s
# Ceiling Temp
  - platform: dallas_temp
    one_wire_id: bus2
    name: "Ceiling Temp"
    id: ceiling_temp_c
    resolution: 10
    update_interval: 5s


################### OUTPUTS ###################

output:

# ---------------- Contactor ----------------

  - platform: gpio
    pin: GPIO13
    id: coil_output

# ---------------- LED MOSFETS ----------------
  - platform: ledc
    pin: GPIO16
    id: pwm_r
    frequency: 19531 Hz
  - platform: ledc
    pin: GPIO17
    id: pwm_g
    frequency: 19531 Hz
  - platform: ledc
    pin: GPIO18
    id: pwm_b
    frequency: 19531 Hz
  - platform: ledc
    pin: GPIO19
    id: pwm_w
    frequency: 19531 Hz

################### LED LIGHTS ###################

light:
  - platform: rgbw
    name: "Sauna RGBW Light"
    red: pwm_r
    green: pwm_g
    blue: pwm_b
    white: pwm_w
    id: sauna_light
    restore_mode: ALWAYS_OFF
    default_transition_length: 1s

################### CLIMATE ###################
climate:
  - platform: thermostat
    name: "Sauna Thermostat"
    id: sauna_thermostat
    sensor: ceiling_temp_c
    min_heating_off_time: 240s
    min_heating_run_time: 240s
    min_idle_time: 30s
    # All Celsius internally (HA will display °F)
    heat_deadband: 1.1         # ≈ 2°F
    heat_overrun: 1.1          # ≈ 2°F
    visual:
      min_temperature: 65.5    # ≈ 150°F
      max_temperature: 93.5    # ≈ 200°F
      temperature_step: 0.5    # ≈ 1°F
    preset:
      - name: "Standard"
        default_target_temperature_low: 82.0 # ≈ 180°F
    default_preset: "Standard"

    heat_action:
      - if:
          condition:
            lambda: 'return !id(fault_latched);'
          then:
            - output.turn_on: coil_output
            - lambda: 'id(coil_is_on) = true;'
            - logger.log: "Heat action -> contactor ON"
          else:
            - output.turn_off: coil_output
            - lambda: 'id(coil_is_on) = false;'
            - logger.log: "Heat action blocked (fault latched) -> contactor OFF"

    idle_action:
      - output.turn_off: coil_output
      - lambda: 'id(coil_is_on) = false;'
      - logger.log: "Idle action -> contactor OFF"

    on_state:
      - logger.log:
          format: "Climate state changed - Current: %.1f°C, Target: %.1f°C, Mode: %s"
          args: ['x.current_temperature', 'x.target_temperature', 'x.mode']


################### SAFETIES ###################

# ---------------- Clear Fault Button ----------------
button:
  - platform: template
    name: "Clear Fault"
    on_press:
      - lambda: |-
          // Convert configurable limit from °F to °C
          float soft_limit_c = (id(soft_high_temp_f).state - 32.0) * 5.0 / 9.0;
          
          if (id(fault_latched) && id(ceiling_temp_c).has_state() && id(ceiling_temp_c).state < soft_limit_c) {
            id(fault_latched) = false;
            id(last_trip_reason) = "";
            ESP_LOGI("safety", "Fault cleared by user.");
          } else if (!id(ceiling_temp_c).has_state()) {
            ESP_LOGW("safety", "Cannot clear fault: ceiling sensor invalid.");
          } else {
            ESP_LOGW("safety", "Cannot clear fault: temperature still above limit (%.1f°C / %.1f°F)", 
                     id(ceiling_temp_c).state, id(ceiling_temp_c).state * 9.0 / 5.0 + 32.0);
          }

# ---------------- Safety Monitoring Loop ----------------
interval:
  - interval: 1s
    then:
      - lambda: |-
          // ============================================
          // 1. DOOR OPEN TIMEOUT FAULT
          // ============================================
          // Only monitor door when heating mode is enabled
          if (id(door_sensor).state && id(sauna_thermostat).mode == climate::CLIMATE_MODE_HEAT) {
            if (id(door_open_since) == 0) {
              id(door_open_since) = millis();
              ESP_LOGD("safety", "Door opened while heating - starting timeout timer");
            } else {
              uint32_t door_open_ms = millis() - id(door_open_since);
              uint32_t fault_ms = (uint32_t)(id(door_open_fault_s).state * 1000);
              
              if (door_open_ms > fault_ms) {
                id(fault_latched) = true;
                id(last_trip_reason) = "Door open timeout (" + 
                                        to_string((int)id(door_open_fault_s).state) + "s exceeded)";
                id(door_open_since) = 0;
                id(coil_output).turn_off();
                ESP_LOGW("safety", "FAULT: Door open timeout after %.0fs!", id(door_open_fault_s).state);
              }
            }
          } else {
            if (id(door_open_since) != 0) {
              ESP_LOGD("safety", "Door closed or heating disabled - resetting timeout timer");
            }
            id(door_open_since) = 0;  // Reset timer when door closes or heating disabled
          }

          // ============================================
          // 2. SOFTWARE HIGH TEMPERATURE FAULT
          // ============================================
          if (id(ceiling_temp_c).has_state()) {
            float temp_f = id(ceiling_temp_c).state * 9.0 / 5.0 + 32.0;
            if (temp_f > id(soft_high_temp_f).state) {
              id(fault_latched) = true;
              id(last_trip_reason) = "Software high temperature (" + 
                                      to_string((int)temp_f) + "°F > " + 
                                      to_string((int)id(soft_high_temp_f).state) + "°F)";
              id(coil_output).turn_off();
              ESP_LOGW("safety", "FAULT: Software high temperature at %.1f°F (limit: %.0f°F)", 
                       temp_f, id(soft_high_temp_f).state);
            }
          }

          // ============================================
          // 3. WELDED CONTACTOR DETECTION
          // ============================================
          // Check if contactor aux shows closed when coil should be OFF
          bool coil_commanded_on = id(coil_is_on);
          bool aux_reports_closed = id(contactor_aux_closed).state;
          
          if (!coil_commanded_on && aux_reports_closed) {
            // Contactor appears welded (aux closed when coil is OFF)
            if (id(welded_detect_since) == 0) {
              id(welded_detect_since) = millis();
              ESP_LOGW("safety", "Possible welded contactor detected (coil OFF but aux closed)");
            } else if (millis() - id(welded_detect_since) > 3000) {  // 3 second confirmation
              id(fault_latched) = true;
              id(last_trip_reason) = "Welded contactor detected (aux closed when coil OFF)";
              id(coil_output).turn_off();
              id(coil_is_on) = false;
              id(welded_detect_since) = 0;
              ESP_LOGE("safety", "FAULT: Welded contactor confirmed after 3s!");
            }
          } else {
            id(welded_detect_since) = 0;  // Reset detection timer
          }

          // ============================================
          // 4. ABSOLUTE SAFETY GUARD
          // ============================================
          // ALWAYS turn off coil if fault latched or heating mode disabled
          if (id(fault_latched) || id(sauna_thermostat).mode != climate::CLIMATE_MODE_HEAT) {
            id(coil_output).turn_off();
            id(coil_is_on) = false;
          }

################### FAULT REPORTING ###################

text_sensor:
  - platform: template
    name: "Last Trip Reason"
    id: last_trip_reason_text
    lambda: |-
      return id(last_trip_reason);
