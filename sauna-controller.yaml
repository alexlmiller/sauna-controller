esphome:
  name: sauna-controller
  friendly_name: Sauna Controller
  project:
    name: sauna.open_controller
    version: "1.0"

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP_TASK_WDT: "y"
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "30"

logger:
  level: INFO
  baud_rate: 0

ota:
  platform: esphome
  password: !secret ota_password

api:
  encryption:
    key: !secret api_key

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: ${friendly_name}_AP
    password: !secret wifi_fallback_pw

web_server:
  port: 80
  
captive_portal:

# ---------------- Globals ----------------
globals:
  - id: fault_latched
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_trip_reason
    type: std::string
    restore_value: no
    initial_value: ""
  - id: session_start_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: session_active
    type: bool
    restore_value: no
    initial_value: "false"
  - id: door_open_since
    type: uint32_t
    restore_value: no
    initial_value: "0"
  # New global to store last valid bench temperature
  - id: last_valid_bench_temp
    type: float
    restore_value: yes
    initial_value: "21.0"  # Room temperature default (70°F)

# ---------------- Door Sensor ----------------
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO21
      mode: INPUT_PULLUP
      inverted: true
    id: door_sensor
    name: "Sauna Door"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms

# Bus 1 for short sensor - GPIO5 with its resistor
one_wire:
  - platform: gpio
    pin: GPIO15
    id: bus1

# Bus 2 for extended sensor - GPIO4 with its resistor  
  - platform: gpio
    pin: GPIO16
    id: bus2

# ---------------- Temperature Sensors (°C, 5s updates) ----------------
sensor:

  - platform: dallas_temp
    one_wire_id: bus1
    name: "Bench Temp"
    id: bench_temp_c
    resolution: 10
    update_interval: 5s

  - platform: dallas_temp
    one_wire_id: bus2
    name: "Ceiling Temp"
    id: ceiling_temp_c
    resolution: 10
    update_interval: 5s


# ---------------- Contactor Output ----------------
output:
  - platform: gpio
    pin: GPIO13
    id: coil_output

  # Lighting PWM
  - platform: ledc
    pin: GPIO32
    id: pwm_r
    frequency: 19531 Hz
  - platform: ledc
    pin: GPIO33
    id: pwm_g
    frequency: 19531 Hz
  - platform: ledc
    pin: GPIO26
    id: pwm_b
    frequency: 19531 Hz
  - platform: ledc
    pin: GPIO25
    id: pwm_w
    frequency: 19531 Hz

light:
  - platform: rgbw
    name: "Sauna RGBW Light"
    red: pwm_r
    green: pwm_g
    blue: pwm_b
    white: pwm_w
    id: sauna_light
    restore_mode: ALWAYS_OFF
    default_transition_length: 1s

# ---------------- Climate (thermostat drives contactor) ----------------
climate:
  - platform: thermostat
    name: "Sauna Thermostat"
    id: sauna_thermostat
    sensor: ceiling_temp_c
    min_heating_off_time: 240s
    min_heating_run_time: 240s
    min_idle_time: 30s
    # All Celsius internally (HA will display °F)
    heat_deadband: 1.1         # ≈ 2°F
    heat_overrun: 1.1          # ≈ 2°F
    visual:
      min_temperature: 65.5    # ≈ 150°F
      max_temperature: 93.5    # ≈ 200°F
      temperature_step: 0.5    # ≈ 1°F
    preset:
      - name: "Standard"
        default_target_temperature_low: 82.0 # ≈ 180°F
    default_preset: "Standard"

    heat_action:
      - if:
          condition:
            lambda: 'return !id(fault_latched);'
          then:
            - output.turn_on: coil_output
            - logger.log: "Heat action -> contactor ON"
          else:
            - output.turn_off: coil_output
            - logger.log: "Heat action blocked (fault latched) -> contactor OFF"

    idle_action:
      - output.turn_off: coil_output
      - logger.log: "Idle action -> contactor OFF"

    on_state:
      - logger.log:
          format: "Climate state changed - Current: %.1f°C, Target: %.1f°C, Mode: %s"
          args: ['x.current_temperature', 'x.target_temperature', 'x.mode']

# ---------------- Clear Fault Button ----------------
button:
  - platform: template
    name: "Clear Fault"
    on_press:
      - lambda: |-
          // 210°F = 98.9°C
          if (id(fault_latched) && id(ceiling_temp_c).has_state() && id(ceiling_temp_c).state < 98.9) {
            id(fault_latched) = false;
            id(last_trip_reason) = "";
            ESP_LOGI("main", "Fault cleared.");
          } else {
            ESP_LOGW("main", "Cannot clear fault: still in overtemp or sensor invalid.");
          }

# ---------------- Safety & Control Guardrail ----------------
interval:
  - interval: 1s
    then:
      - lambda: |-
          // Door timeout only when heating mode is enabled
          if (id(door_sensor).state && id(sauna_thermostat).mode == climate::CLIMATE_MODE_HEAT) {
            if (id(door_open_since) == 0) id(door_open_since) = millis();
            else if (millis() - id(door_open_since) > 60000) { // 60s
              id(fault_latched) = true;
              id(last_trip_reason) = "Door open too long";
              id(door_open_since) = 0;
              id(coil_output).turn_off();
              ESP_LOGW("main", "Door open timeout fault!");
            }
          } else {
            id(door_open_since) = 0;
          }

          // Software high temp safety (210°F = 98.9°C)
          if (id(ceiling_temp_c).has_state() && id(ceiling_temp_c).state > 98.9) {
            id(fault_latched) = true;
            id(last_trip_reason) = "Software high temperature limit";
            id(coil_output).turn_off();
            ESP_LOGW("main", "Software high temperature fault at %.1f°C!", id(ceiling_temp_c).state);
          }

          // Absolute guard
          if (id(fault_latched) || id(sauna_thermostat).mode != climate::CLIMATE_MODE_HEAT) {
            id(coil_output).turn_off();
          }

text_sensor:
  - platform: template
    name: "Last Trip Reason"
    id: last_trip_reason_text
    lambda: |-
      return id(last_trip_reason);
