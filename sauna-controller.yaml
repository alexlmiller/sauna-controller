esphome:
  name: sauna_controller
  friendly_name: Sauna Controller
  comment: Full sauna controller with RGBW lighting, door sensor, manual mode, safeties
  platform: ESP32
  board: esp32dev
  project:
    name: sauna.open_controller
    version: "1.0"

# Enable logging with dynamic debug control
logger:
  level: INFO
  baud_rate: 0

# Enable OTA
ota:
  password: !secret ota_password

# Enable API for Home Assistant
api:
  encryption:
    key: !secret api_key

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "SaunaController Fallback"
    password: "fallbackpw"

captive_portal:

# Enable Watchdog (safety-critical)
esp32:
  board: esp32dev
  framework:
    type: arduino
  watchdog_timeout: 30s

# Global variables
globals:
  - id: fault_latched
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_trip_reason
    type: std::string
    restore_value: no
    initial_value: ""
  - id: session_start_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: session_active
    type: bool
    restore_value: no
    initial_value: "false"
  - id: door_open_since
    type: uint32_t
    restore_value: no
    initial_value: "0"

# Switch for master enable
switch:
  - platform: template
    name: "Sauna Master Enable"
    id: master_enable
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - logger.log: "Master Enabled"
    turn_off_action:
      - logger.log: "Master Disabled"
      - switch.turn_off: coil_relay

# Coil Relay
switch:
  - platform: gpio
    pin: GPIO16
    id: coil_relay
    name: "Heater Contactor Coil"
    restore_mode: ALWAYS_OFF

# Door sensor
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO17
      mode: INPUT_PULLUP
      inverted: true
    id: door_sensor
    name: "Sauna Door"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms

# High-limit thermostat status (manual reset)
  - platform: gpio
    pin:
      number: GPIO18
      mode: INPUT_PULLUP
      inverted: true
    id: high_limit_trip
    name: "High Limit Trip"
    filters:
      - delayed_on: 100ms

# Sensors
sensor:
  - platform: max31865
    cs_pin: GPIO5
    spi_id: bus_a
    rtd_nominal: 100.0
    reference_resistance: 430.0
    wires: 3
    name: "Ceiling Temp"
    id: ceiling_temp_f
    unit_of_measurement: "°F"
    accuracy_decimals: 1
    filters:
      - lambda: return x * 9.0 / 5.0 + 32.0;

  - platform: max31865
    cs_pin: GPIO4
    spi_id: bus_a
    rtd_nominal: 100.0
    reference_resistance: 430.0
    wires: 3
    name: "Bench Temp"
    id: bench_temp_f
    unit_of_measurement: "°F"
    accuracy_decimals: 1
    filters:
      - lambda: return x * 9.0 / 5.0 + 32.0;

# SPI bus for MAX31865s
spi:
  id: bus_a
  clk_pin: GPIO14
  mosi_pin: GPIO13
  miso_pin: GPIO12

# Climate control
climate:
  - platform: thermostat
    name: "Sauna Thermostat"
    sensor: ceiling_temp_f
    min_heating_off_time: 120s
    min_heating_run_time: 120s
    min_idle_time: 30s
    heat_deadband: 2°F
    heat_overrun: 2°F
    default_target_temperature_low: 180°F
    default_target_temperature_high: 180°F
    visual:
      min_temperature: 150°F
      max_temperature: 200°F
      temperature_step: 1°F
    id: sauna_thermostat

# Lighting
output:
  - platform: ledc
    pin: GPIO21
    id: pwm_r
    frequency: 19531Hz
  - platform: ledc
    pin: GPIO22
    id: pwm_g
    frequency: 19531Hz
  - platform: ledc
    pin: GPIO27
    id: pwm_b
    frequency: 19531Hz
  - platform: ledc
    pin: GPIO33
    id: pwm_w
    frequency: 19531Hz

light:
  - platform: rgbw
    name: "Sauna RGBW Light"
    red: pwm_r
    green: pwm_g
    blue: pwm_b
    white: pwm_w
    id: sauna_light
    restore_mode: ALWAYS_OFF
    default_transition_length: 1s

# Fault clear button
button:
  - platform: template
    name: "Clear Fault"
    on_press:
      - lambda: |-
          if (id(fault_latched) && id(ceiling_temp_f).has_state() && id(ceiling_temp_f).state < 210.0) {
            id(fault_latched) = false;
            id(last_trip_reason) = "";
            ESP_LOGI("main", "Fault cleared.");
          } else {
            ESP_LOGW("main", "Cannot clear fault: still in overtemp or sensor invalid.");
          }

# Main control loop
interval:
  - interval: 1s
    then:
      - lambda: |-
          // Safety: hardware high-limit
          if (id(high_limit_trip).state) {
            id(fault_latched) = true;
            id(last_trip_reason) = "Hardware high limit";
            id(coil_relay).turn_off();
          }

          // Safety: door timeout
          if (id(door_sensor).state && id(master_enable).state) {
            if (id(door_open_since) == 0) id(door_open_since) = millis();
            else if (millis() - id(door_open_since) > 60000) { // 60s
              id(fault_latched) = true;
              id(last_trip_reason) = "Door open too long";
              id(coil_relay).turn_off();
            }
          } else {
            id(door_open_since) = 0;
          }

          // Control
          if (!id(fault_latched) && id(master_enable).state) {
            if (id(sauna_thermostat).mode == climate::CLIMATE_MODE_HEAT) {
              if (id(ceiling_temp_f).state < id(sauna_thermostat).target_temperature - 1) {
                id(coil_relay).turn_on();
              } else if (id(ceiling_temp_f).state >= id(sauna_thermostat).target_temperature + 1) {
                id(coil_relay).turn_off();
              }
            } else {
              id(coil_relay).turn_off();
            }
          } else {
            id(coil_relay).turn_off();
          }

text_sensor:
  - platform: template
    name: "Last Trip Reason"
    id: last_trip_reason_text
    lambda: |-
      return id(last_trip_reason).c_str();

